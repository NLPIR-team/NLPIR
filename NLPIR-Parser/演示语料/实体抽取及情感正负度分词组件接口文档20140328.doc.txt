



å®ä½“æŠ½å–åŠæƒ…æ„Ÿæ­£è´Ÿåº¦åˆ†æç»„ä»¶ 
æ¥å£æ–‡æ¡£  
























http://ICTCLAS.nlpir.org/
@ICTCLASå¼ åå¹³åšå£«
2012-12


ç›®å½•
å®ä½“æŠ½å–åŠæƒ…æ„Ÿæ­£è´Ÿåº¦åˆ†æç»„ä»¶	1
æ¥å£æ–‡æ¡£	1
ç›®å½•	3
0. å®ä½“æŠ½å–ç»„ä»¶ç®€ä»‹	4
1ï¼Cï¼‹ï¼‹æ¥å£	5
1.1 DE_Init	5
1.2 DE_Exit()	7
1.3 DE_ParseDoc	8
1.4 CLUS_AddContent	11
1.5 DE_GetLastErrMsg	12
2  DocExtratorè¿è¡Œç¯å¢ƒ	13
3 å¸¸è§é—®é¢˜ï¼ˆFAQï¼‰	14
Q1: Linuxè°ƒç”¨libDocExtrator.soçš„æ—¶å€™ï¼Œé“¾æ¥ä¸ä¸Šåº“	14
Q2: DocExtractorç³»ç»Ÿåˆå§‹åŒ–è€æ˜¯å¤±è´¥	14
4 ä½œè€…ç®€ä»‹	15


0. å®ä½“æŠ½å–ç»„ä»¶ç®€ä»‹
ã€€ã€€å®ä½“æŠ½å–ï¼ˆEntity Extratorï¼‰å®ä½“å…³ç³»æŠ½å–æ˜¯æŒ‡è‡ªåŠ¨è¯†åˆ«åŒ…å«åœ¨è‡ªç„¶è¯­è¨€æ–‡æœ¬ä¸­çš„ä¸¤ä¸ªå®ä½“ä¹‹é—´çš„é¢„å®šä¹‰å…³ç³»ã€‚æ‰€è°“å®ä½“æ˜¯æŒ‡æ–‡æœ¬ä¸­åŒ…å«çš„ç‰¹å®šäº‹å®ä¿¡æ¯,å¦‚äººç‰©ã€ç»„ç»‡æœºæ„ã€åœ°ç†ä½ç½®ç­‰ã€‚å®ä½“å…³ç³»æŠ½å–åœ¨æ•°æ®ç»“æ„åŒ–ã€ä¿¡æ¯æ£€ç´¢å’Œè‡ªåŠ¨åº”ç­”ç³»ç»Ÿç­‰é¢†åŸŸæœ‰ç€é‡è¦çš„ç ”ç©¶æ„ä¹‰ã€‚ç¾å›½å›½å®¶æ ‡å‡†æŠ€æœ¯ç ”ç©¶é™¢(NIST)åœ¨2008å¹´ç»„ç»‡çš„è‡ªåŠ¨å†…å®¹æŠ½å–(ACE,AutomaticContentExtraction)è¯„æµ‹ä¸­å®šä¹‰äº†7ç§å®ä½“å…³ç³»ç±»å‹å’Œ18ç§å­ç±»å‹ã€‚
ã€€ã€€
ã€€ã€€è‡ªç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°/J nHB-O(b1[
ã€€ã€€Y
ã€€ã€€X
ã€€ã€€
ã€€ã€€
ã€€ã€€   è®¿é—®http://ictclas.nlpir.org/(è‡ªç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°)ï¼Œæ‚¨å¯ä»¥è·å–DocExtratorç»„ä»¶çš„æœ€æ–°ç‰ˆæœ¬ï¼Œå¹¶æ¬¢è¿æ‚¨å…³æ³¨å¼ åå¹³åšå£«çš„æ–°æµªå¾®åš @ICTCLASå¼ åå¹³åšå£« äº¤æµã€‚1P_bR$vk0 è‡ªç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°1H9^+}NE*W;^
è‡ªç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°5H8]U ]4`s"Q^


6b;t.P s@)\J0ç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°-l3?3v"Z#X|{t#A!d Z å›¾1ï¼šæ–‡æ¡£æ­£è´Ÿæƒ…æ„Ÿåˆ†æåŠŸèƒ½å±•ç¤º
è‡ªç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°-r
UM"c3u ]
1ï¼Cï¼‹ï¼‹æ¥å£
1.1 DE_Init
Init the analyzer and prepare necessary data for DocExtrator according the configure file.
int DE_Init(const char *sPath=0,int nEncoding=GBK_CODE,const char *sLicenseCode=0);
RoutineRequired HeaderDE_Init<DocExtractor.h>Return Value
Return true if init succeed. Otherwise return false.
Parameters
sDefaultPath: Initial Directory Path, where Data directory stored.  the default value is 0, it indicates the initial directory is current working directory path
nEncoding:  Encoding of input string, default is GBK_CODE (GBK encoding), and it can be set with UTF8_CODE (UTF8 encoding) and BIG5_CODE (BIG5 encoding).
const char* sLicenceCode: licence coding of input string, 
Remarks
The DE_Init function must be invoked before any operation with DocExtrator. The whole system need call the function only once before starting DocExtrator. When stopping the system and make no more operation, DE_Exit should be invoked to destroy all working buffer. Any operation will fail if init do not succeed.
DE_Init fails mainly because of two reasons: 1) Required data is incompatible or missing 2) invalid parameters. Moreover, you could learn more from the log file 2014****.log in the current directory. 
Example
int main(int argc, char* argv[])
{
	// åˆå§‹åŒ–	
	if(!DE_Init("",UTF8_CODE)) {
		printf("%s\n", DE_GetLastErrMsg());
		return 1;
	}

	// æ‰«æ
	int nRealCount;
	vector<string> vsFileName;
	fn_vScanFiles(argv[1], vsFileName,"txt");

	//fn_vScanFiles(std::string& sFolderName, std::vector<std::string>& vsFileName,tstring& sFilter)
	string sOutput = "";

	// åŠ è½½
	printf("åˆ†ææ–‡ç« ï¼ˆTotal %dï¼‰...\n",vsFileName.size());
	int i;
	_tDocExtractResult result;
	for(i=0; i<vsFileName.size(); i++) {
		string sContent;
		gfn_bReadFile(vsFileName[i].c_str(), sContent);
		DE_ParseDoc(sContent.c_str(),result,true);//,LOCATION_REQUIRED|ORGANIZATION_REQUIRED|PERSON_REQUIRED
		printf("-------------------------------------\næ–‡ä»¶:%s\nå†…å®¹ï¼š\n%s\n\n------------------------------------\nåˆ†æç»“æœï¼š\n", vsFileName[i].c_str(), sContent.c_str());
		printf("Person list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_PERSON]);
		printf("Loc list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_LOCATION]);
		printf("Org list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_ORGANIZATION]);
		printf("Abstract list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_ABSTRACT]);
		printf("Keyword list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_KEYWORD]);
		printf("Media list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_MEDIA]);
		printf("Author list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_AUTHOR]);
		printf("Country:%s\n",result.entity_list[DOC_EXTRACT_TYPE_COUNTRY]);
		printf("Province:%s\n",result.entity_list[DOC_EXTRACT_TYPE_PROVINCE]);
		printf("Food:%s\n",result.entity_list[DOC_EXTRACT_TYPE_FOOD]);
		printf("Transportation:%s\n",result.entity_list[DOC_EXTRACT_TYPE_TRANS]);
		printf("Apps:%s\n",result.entity_list[DOC_EXTRACT_TYPE_APPS]);
		printf("SENTIMENT:%d\n",result.sentiment_score);
		fTime=(float)lTime/(float)CLOCKS_PER_SEC;//Time cost
		printf("Size=%d Bytes\n",sContent.size());
	}

	// é€€å‡º
	DE_Exit();
	return 0;
}
Output
1.2 DE_Exit()
Exit the program and free all resources and destroy all working buffer used in DocExtrator.
void DE_Exit();
RoutineRequired HeaderDE_Exit<DocExtractor.h>Return Value
none.
Parameters
none
Remarks
The DE_Exit function must be invoked while stopping the system and make no more operation. And call DE_Exit function to restart DocExtrator. 
Example
int main(int argc, char* argv[])
{
	// åˆå§‹åŒ–	
	if(!DE_Init("",UTF8_CODE)) {
		printf("%s\n", DE_GetLastErrMsg());
		return 1;
	}

	// æ‰«æ
	int nRealCount;
	vector<string> vsFileName;
	fn_vScanFiles(argv[1], vsFileName,"txt");

	//fn_vScanFiles(std::string& sFolderName, std::vector<std::string>& vsFileName,tstring& sFilter)
	string sOutput = "";

	// åŠ è½½
	printf("åˆ†ææ–‡ç« ï¼ˆTotal %dï¼‰...\n",vsFileName.size());
	int i;
	_tDocExtractResult result;
	for(i=0; i<vsFileName.size(); i++) {
		string sContent;
		gfn_bReadFile(vsFileName[i].c_str(), sContent);
		DE_ParseDoc(sContent.c_str(),result,true);//,LOCATION_REQUIRED|ORGANIZATION_REQUIRED|PERSON_REQUIRED
		printf("-------------------------------------\næ–‡ä»¶:%s\nå†…å®¹ï¼š\n%s\n\n------------------------------------\nåˆ†æç»“æœï¼š\n", vsFileName[i].c_str(), sContent.c_str());
		printf("Person list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_PERSON]);
		printf("Loc list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_LOCATION]);
		printf("Org list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_ORGANIZATION]);
		printf("Abstract list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_ABSTRACT]);
		printf("Keyword list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_KEYWORD]);
		printf("Media list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_MEDIA]);
		printf("Author list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_AUTHOR]);
		printf("Country:%s\n",result.entity_list[DOC_EXTRACT_TYPE_COUNTRY]);
		printf("Province:%s\n",result.entity_list[DOC_EXTRACT_TYPE_PROVINCE]);
		printf("Food:%s\n",result.entity_list[DOC_EXTRACT_TYPE_FOOD]);
		printf("Transportation:%s\n",result.entity_list[DOC_EXTRACT_TYPE_TRANS]);
		printf("Apps:%s\n",result.entity_list[DOC_EXTRACT_TYPE_APPS]);
		printf("SENTIMENT:%d\n",result.sentiment_score);
		fTime=(float)lTime/(float)CLOCKS_PER_SEC;//Time cost
		printf("Size=%d Bytes\n",sContent.size());
	}

	// é€€å‡º
	DE_Exit();
	return 0;
}
Output
1.3 DE_ParseDoc
Generation of single document summarization.
bool DE_ParseDoc(const char *sText,_tDocExtractResult& result,bool bSummaryNeeded=true,unsigned int nFuncRequired=ALL_REQUIRED);
RoutineRequired HeaderDE_ParseDoc<DocExtractor.h>Return Value
Return true if init succeed. Otherwise return false.
Parameters
sText:  document content
result:   document extract result
typedef struct _tDocExtractResult{
Char  entity_list[DOC_EXTRACT_TYPE_COUNT][DOC_EXTRACT_TYPE_MAX_LENGTH+1];
   //personal name list, delimiter with #
int sentiment_score;//æƒ…æ„Ÿææ€§åˆ¤åˆ†
}DOC_EXTRAXT_RESULT;
bSummaryNeeded: whether or not calculated summary
Remarks
Example
int main(int argc, char* argv[])
{
	// åˆå§‹åŒ–	
	if(!DE_Init("",UTF8_CODE)) {
		printf("%s\n", DE_GetLastErrMsg());
		return 1;
	}

	// æ‰«æ
	int nRealCount;
	vector<string> vsFileName;
	fn_vScanFiles(argv[1], vsFileName,"txt");
	string sOutput = "";

	// åŠ è½½
	printf("åˆ†ææ–‡ç« ï¼ˆTotal %dï¼‰...\n",vsFileName.size());
	int i;
	_tDocExtractResult result;
	for(i=0; i<vsFileName.size(); i++) {
		string sContent;
		gfn_bReadFile(vsFileName[i].c_str(), sContent);
		DE_ParseDoc(sContent.c_str(),result,true);//,LOCATION_REQUIRED|ORGANIZATION_REQUIRED|PERSON_REQUIRED
		printf("-------------------------------------\næ–‡ä»¶:%s\nå†…å®¹ï¼š\n%s\n\n------------------------------------\nåˆ†æç»“æœï¼š\n", vsFileName[i].c_str(), sContent.c_str());
		printf("Person list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_PERSON]);
		printf("Loc list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_LOCATION]);
		printf("Org list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_ORGANIZATION]);
		printf("Abstract list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_ABSTRACT]);
		printf("Keyword list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_KEYWORD]);
		printf("Media list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_MEDIA]);
		printf("Author list:%s\n",result.entity_list[DOC_EXTRACT_TYPE_AUTHOR]);
		printf("Country:%s\n",result.entity_list[DOC_EXTRACT_TYPE_COUNTRY]);
		printf("Province:%s\n",result.entity_list[DOC_EXTRACT_TYPE_PROVINCE]);
		printf("Food:%s\n",result.entity_list[DOC_EXTRACT_TYPE_FOOD]);
		printf("Transportation:%s\n",result.entity_list[DOC_EXTRACT_TYPE_TRANS]);
		printf("Apps:%s\n",result.entity_list[DOC_EXTRACT_TYPE_APPS]);
		printf("SENTIMENT:%d\n",result.sentiment_score);
		fTime=(float)lTime/(float)CLOCKS_PER_SEC;//Time cost
		printf("Size=%d Bytes\n",sContent.size());
	}

	// é€€å‡º
	DE_Exit();
	return 0;
}
Output


1.4 CLUS_AddContent

get Positive or negative emotion in the document.

int  DE_ComputeSentimentDoc(const char *sText);
RoutineRequired HeaderDE_ComputeSentimentDoc<DocExtractor.h>Return Value
the emotional value about the document.
Parameters
sText: [IN] Document content

Remarks
This function can be performed repeatedly before the result is printed
in the process
Example
int main(int argc, char* argv[])
{
	// åˆå§‹åŒ–	
	if(!DE_Init("",UTF8_CODE)) {
		printf("%s\n", DE_GetLastErrMsg());
		return 1;
	}
	// æ‰«æ
	int nRealCount;
	vector<string> vsFileName;
	fn_vScanFiles(argv[1], vsFileName,"txt");
	string sOutput = "";
	printf("åˆ†ææ–‡ç« ï¼ˆTotal %dï¼‰...\n",vsFileName.size());
	int i;
	for(i=0; i<vsFileName.size(); i++) {
		string sContent;
		gfn_bReadFile(vsFileName[i].c_str(), sContent);
		int nSent = DE_ComputeSentimentDoc(sContent.c_str());
		printf("SENTIMENT:%d\n",nSent);	
	}

	// é€€å‡º
	DE_Exit();
}
Output

1.5 DE_GetLastErrMsg
const char* DE_GetLastErrMsg();
RoutineRequired HeaderDE_GetLastErrMsg<DocExtractor.h>Return Value
Return the lastest error msg.

Parameters
NULL
Remarks
This function can be performed repeatedly before the result is printed
in the process
Example
int main(int argc, char* argv[])
{
	// åˆå§‹åŒ–	
	if(!DE_Init("",UTF8_CODE)) {
		printf("%s\n", DE_GetLastErrMsg());
		return 1;
	}
	// æ‰«æ
	int nRealCount;
	vector<string> vsFileName;
	fn_vScanFiles(argv[1], vsFileName,"txt");
	string sOutput = "";
	printf("åˆ†ææ–‡ç« ï¼ˆTotal %dï¼‰...\n",vsFileName.size());
	int i;
	for(i=0; i<vsFileName.size(); i++) {
		string sContent;
		gfn_bReadFile(vsFileName[i].c_str(), sContent);
		int nSent = DE_ComputeSentimentDoc(sContent.c_str());
		printf("SENTIMENT:%d\n",nSent);	
	}

	// é€€å‡º
	DE_Exit();
}
Output

2  DocExtratorè¿è¡Œç¯å¢ƒ
   1. å¯ä»¥æ”¯æŒWindowsã€Linuxã€FreeBSDç­‰å¤šç§ç¯å¢ƒï¼Œæ”¯æŒæ™®é€šPCæœºå™¨å³å¯è¿è¡Œã€‚
   2. æ”¯æŒGBK/UTF-8/BIG5

3 å¸¸è§é—®é¢˜ï¼ˆFAQï¼‰
Q1: Linuxè°ƒç”¨libDocExtrator.soçš„æ—¶å€™ï¼Œé“¾æ¥ä¸ä¸Šåº“
ä¾‹å¦‚æ‰§è¡Œç¤ºä¾‹ç¨‹åºç»“æœå¦‚ä¸‹ï¼š
[root@localhost linux_c_sample]# ./test 
./test: error while loading shared libraries: libDocExtrator.so: cannot open shared object file: No such file or directory
Answer: 
åº”å½“è®¾ç½®ç³»ç»Ÿçš„LD_LIBRARY_PATHï¼Œå³ï¼šexport LD_LIBRARY_PATH=./
å¹¶ä¸”è¯·ä¿è¯åœ¨æœ¬ç›®å½•ä¹Ÿæœ‰libNLPIR.so
Q2: DocExtractorç³»ç»Ÿåˆå§‹åŒ–è€æ˜¯å¤±è´¥
Answer: 
è¯·æ‚¨ä¿è¯NLPIR.useræ–‡ä»¶æœªè¿‡æœŸï¼Œå¦å¤–å¯å‚è€ƒ"20***.err"æ–‡ä»¶æŸ¥çœ‹é”™è¯¯ä¿¡æ¯














4 ä½œè€…ç®€ä»‹






å¼ åå¹³ åšå£« å‰¯æ•™æˆ ç¡•å¯¼
åŒ—äº¬ç†å·¥å¤§å­¦è®¡ç®—æœºå­¦é™¢ é™¢é•¿åŠ©ç†
åŒ—äº¬ç†å·¥å¤§å­¦ç½‘ç»œæœç´¢æŒ–æ˜ä¸å®‰å…¨å®éªŒå®¤ ä¸»ä»»
åœ°å€ï¼šåŒ—äº¬æµ·æ·€åŒºä¸­å…³æ‘å—å¤§è¡—5å· 100081
ç”µè¯ï¼š+86-10-68918642
Email:kevinzhang@bit.edu.cn
MSN:  pipy_zhang@msn.com;
ç½‘ç«™: http://ictclas.nlpir.org (è‡ªç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°)
åšå®¢:http://hi.baidu.com/drkevinzhang/
å¾®åš: @ICTCLASå¼ åå¹³åšå£«


Dr. Kevin Zhang  (å¼ åå¹³ï¼ŒZhang Hua-Ping)
Associate Professor, Graduate Supervisor
Dean Assistant, School of Computer
Director, Web Search,Mining and Security Lab.
Beijing Institute of Technology 
Add: No.5, South St.,Zhongguancun,Haidian District,Beijing,P.R.C  PC:100081
Tel: +86-10-68918642
Email:kevinzhang@bit.edu.cn
MSN:  pipy_zhang@msn.com;
Website: http://ictclas.nlpir.org (Natural Language Processing and Information Retrieval Sharing Platform)
Blog:http://hi.baidu.com/drkevinzhang/
Twitter: @ICTCLASå¼ åå¹³åšå£«


æƒ…æ„Ÿæ­£è´Ÿåº¦ç»„ä»¶(DocExtrator) æ¥å£æ–‡æ¡£            http://ICTCLAS.nlpir.org

NLPIR Copyright (c) 2013 Kevin Zhang. All rights reserved.    	               1/2

