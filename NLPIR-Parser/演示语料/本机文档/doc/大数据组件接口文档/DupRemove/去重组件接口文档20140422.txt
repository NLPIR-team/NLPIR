



å»é‡ç»„ä»¶æ¥å£æ–‡æ¡£  
























http://ICTCLAS.nlpir.org/
@ICTCLASå¼ åå¹³åšå£«
2012-12


ç›®å½•
å»é‡ç»„ä»¶æ¥å£æ–‡æ¡£	1
ç›®å½•	2
0. å»é‡ç»„ä»¶ç®€ä»‹	3
1ï¼Cï¼‹ï¼‹æ¥å£	4
1.1 RR_Init	4
1.2 RR_Exit;	5
1.3 RR_FileProcess	6
1.4 RR_FindRepeat	7
1.5 RR_Output	9
1.6 RR_SaveData	11
1.7 RR_GetLastErrMsg	12
2  LJDupRemoverè¿è¡Œç¯å¢ƒ	14
3 å¸¸è§é—®é¢˜ï¼ˆFAQï¼‰	15
Q: LJDupRemoverç³»ç»Ÿåˆå§‹åŒ–è€æ˜¯å¤±è´¥	15
4 ä½œè€…ç®€ä»‹	15


0. å»é‡ç»„ä»¶ç®€ä»‹
ã€€ã€€èƒ½å¤Ÿå¿«é€Ÿå‡†ç¡®åœ°åˆ¤æ–­æ–‡ä»¶é›†åˆæˆ–æ•°æ®åº“ä¸­æ˜¯å¦å­˜åœ¨ç›¸åŒæˆ–ç›¸ä¼¼å†…å®¹çš„è®°å½•ï¼ŒåŒæ—¶æ‰¾å‡ºæ‰€æœ‰çš„é‡å¤è®°å½•ã€‚
ã€€ã€€è‡ªç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°/J nHB-O(b1[
ã€€ã€€Y
ã€€ã€€X
ã€€ã€€
ã€€ã€€
ã€€ã€€   è®¿é—®http://ictclas.nlpir.org/(è‡ªç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°)ï¼Œæ‚¨å¯ä»¥è·å–LJDupRemoverç»„ä»¶çš„æœ€æ–°ç‰ˆæœ¬ï¼Œå¹¶æ¬¢è¿æ‚¨å…³æ³¨å¼ åå¹³åšå£«çš„æ–°æµªå¾®åš @ICTCLASå¼ åå¹³åšå£« äº¤æµã€‚1P_bR$vk0 è‡ªç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°1H9^+}NE*W;^
è‡ªç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°5H8]U ]4`s"Q^


6b;t.P s@)\J0ç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°-l3?3v"Z#X|{t#A!d Z å›¾1ï¼šæ–‡æ¡£å»é‡åŠŸèƒ½å±•ç¤º
è‡ªç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°-r
UM"c3u ]
1ï¼Cï¼‹ï¼‹æ¥å£
1.1 RR_Init
Init the analyzer and prepare necessary data for LJDupRemove according the configure file.
bool RR_Init(const char *DataFilePath = "Data.txt", const char *sLicenseCode=0);
RoutineRequired HeaderRR_Init<LJDupRemover.h>Return Value
Return true if init succeed. Otherwise return false.
Parameters
DataFilePath : Initial , load the "Data.txt" file that contain  Duplicate removal data.
const char* sLicenceCode: licence coding of input string, 
Remarks
The RR_Init function must be invoked before any operation with LJDupRemove. The whole system need call the function only once before starting LJDupRemove. When stopping the system and make no more operation, RR_Exit should be invoked to destroy all working buffer. Any operation will fail if init do not succeed.
RR_Init  fails mainly because of two reasons: 1) Required data.txt is incompatible or missing 2) invalid parameters. Moreover, you could learn more from the log file 2014****.log in the current directory. 
Example
int _tmain(int argc, _TCHAR* argv[])
{
	if (!RR_Init("RR_Data.txt","Data"))
	{
		printf("%s\r\n", RR_GetLastErrMsg());
		printf("å»é‡ç»„ä»¶åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·é€€å‡ºå¹¶æ£€æŸ¥ï¼è¯¥è”ç³»www.nlpir.org/æˆ–è€…æ–°æµªå¾®åš@ICTCLASå¼ åå¹³åšå£«ï¼\n");
		return-1;
	}

	vector<string> fileDir;
	string path = "./test/";
	string sContent = "";
	if(!gfn_bScanFiles(path.c_str(),fileDir))
	{
		printf("è·å–æ–‡ä»¶å¤¹ä¸­æ–‡ä»¶å¤±è´¥......\n");
		system("pause");
		return -1;
	}
	string sFilename;
	char *pcFindAll = new char[65565];
	for (int i = 0; i < fileDir.size();i++)
	{
		gfn_bReadFile((path + fileDir.at(i)).c_str(), sContent);
		sFilename = fileDir.at(i).c_str();
		sContent += "\r\n";
		if (RR_FileProcess(sContent.c_str(), sFilename.c_str()) == 1)
		{
			memset(pcFindAll, 0, 65565);
			RR_FindRepeat(pcFindAll, true);
		}
	}

	if (pcFindAll != NULL)
	{
		delete[] pcFindAll;
		pcFindAll = NULL;
	}

	RR_Output("");
	RR_SaveData("RR_Data.txt");
ã€€ã€€RR_Exit();
	return 0;
}
Output
1.2 RR_Exit;
Exit the program and free all resources and destroy all working buffer used in LJDupRemover.
void RR_Exit();
RoutineRequired HeaderRR_Exit<LJDupRemover.h>Return Value
none.
Parameters
none
Remarks
The RR_Exit function must be invoked while stopping the system and make no more operation. And call RR_Exit function to restart LJDupRemover. 
Example
çœ‹ä¸Šä¾‹çº¢è‰²ã€‚
Output
1.3 RR_FileProcess
int RR_FileProcess(const char *FileText, const char *FileName);
RoutineRequired HeaderRR_FileProcess<LJDupRemover.h>Return Value
Return 1 if FileProcess check duplicate content. Otherwise return other.
Parameters
FileText:  file content that paragraph 2;
FileName:   filename that will be processed.
Remarks
Example
int _tmain(int argc, _TCHAR* argv[])
{
	if (!RR_Init("RR_Data.txt","Data"))
	{
		printf("%s\r\n", RR_GetLastErrMsg());
		printf("å»é‡ç»„ä»¶åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·é€€å‡ºå¹¶æ£€æŸ¥ï¼è¯¥è”ç³»www.nlpir.org/æˆ–è€…æ–°æµªå¾®åš@ICTCLASå¼ åå¹³åšå£«ï¼\n");
		return-1;
	}

	vector<string> fileDir;
	string path = "./test/";
	string sContent = "";
	if(!gfn_bScanFiles(path.c_str(),fileDir))
	{
		printf("è·å–æ–‡ä»¶å¤¹ä¸­æ–‡ä»¶å¤±è´¥......\n");
		system("pause");
		return -1;
	}
	string sFilename;
	char *pcFindAll = new char[65565];
	for (int i = 0; i < fileDir.size();i++)
	{
		gfn_bReadFile((path + fileDir.at(i)).c_str(), sContent);
		sFilename = fileDir.at(i).c_str();
		sContent += "\r\n";
		if (RR_FileProcess(sContent.c_str(), sFilename.c_str()) == 1)
		{
			memset(pcFindAll, 0, 65565);
			RR_FindRepeat(pcFindAll, true);
		}
	}

	if (pcFindAll != NULL)
	{
		delete[] pcFindAll;
		pcFindAll = NULL;
	}

	RR_Output("");
	RR_SaveData("RR_Data.txt");
ã€€ã€€RR_Exit();
	return 0;
}
Output


1.4 RR_FindRepeat


bool RR_FindRepeat(char * ReturnString, bool isAll = false);
RoutineRequired HeaderRR_FindRepeat<LJDupRemover.h>Return Value
Return true if succeed. Otherwise return false.
Parameters
ReturnString: [OUT]  duplicate content
isAll : contain all duplicate content or not

Remarks
This function can be performed repeatedly before the result is printed
in the process
Example
int _tmain(int argc, _TCHAR* argv[])
{
	if (!RR_Init("RR_Data.txt","Data"))
	{
		printf("%s\r\n", RR_GetLastErrMsg());
		printf("å»é‡ç»„ä»¶åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·é€€å‡ºå¹¶æ£€æŸ¥ï¼è¯¥è”ç³»www.nlpir.org/æˆ–è€…æ–°æµªå¾®åš@ICTCLASå¼ åå¹³åšå£«ï¼\n");
		return-1;
	}

	vector<string> fileDir;
	string path = "./test/";
	string sContent = "";
	if(!gfn_bScanFiles(path.c_str(),fileDir))
	{
		printf("è·å–æ–‡ä»¶å¤¹ä¸­æ–‡ä»¶å¤±è´¥......\n");
		system("pause");
		return -1;
	}
	string sFilename;
	char *pcFindAll = new char[65565];
	for (int i = 0; i < fileDir.size();i++)
	{
		gfn_bReadFile((path + fileDir.at(i)).c_str(), sContent);
		sFilename = fileDir.at(i).c_str();
		sContent += "\r\n";
		if (RR_FileProcess(sContent.c_str(), sFilename.c_str()) == 1)
		{
			memset(pcFindAll, 0, 65565);
			RR_FindRepeat(pcFindAll, true);
		}
	}

	if (pcFindAll != NULL)
	{
		delete[] pcFindAll;
		pcFindAll = NULL;
	}

	RR_Output("");
	RR_SaveData("RR_Data.txt");
ã€€ã€€RR_Exit();
	return 0;
}
Output

1.5 RR_Output
bool RR_Output(const char *OutputPath = "RepeatFile.txt");
RoutineRequired HeaderRR_Output<LJDupRemover.h>Return Value
Return true if init succeed. Otherwise return false.

Parameters
OutputPath : output Duplicate removal result record;
Example
int _tmain(int argc, _TCHAR* argv[])
{
	if (!RR_Init("RR_Data.txt","Data"))
	{
		printf("%s\r\n", RR_GetLastErrMsg());
		printf("å»é‡ç»„ä»¶åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·é€€å‡ºå¹¶æ£€æŸ¥ï¼è¯¥è”ç³»www.nlpir.org/æˆ–è€…æ–°æµªå¾®åš@ICTCLASå¼ åå¹³åšå£«ï¼\n");
		return-1;
	}

	vector<string> fileDir;
	string path = "./test/";
	string sContent = "";
	if(!gfn_bScanFiles(path.c_str(),fileDir))
	{
		printf("è·å–æ–‡ä»¶å¤¹ä¸­æ–‡ä»¶å¤±è´¥......\n");
		system("pause");
		return -1;
	}
	string sFilename;
	char *pcFindAll = new char[65565];
	for (int i = 0; i < fileDir.size();i++)
	{
		gfn_bReadFile((path + fileDir.at(i)).c_str(), sContent);
		sFilename = fileDir.at(i).c_str();
		sContent += "\r\n";
		if (RR_FileProcess(sContent.c_str(), sFilename.c_str()) == 1)
		{
			memset(pcFindAll, 0, 65565);
			RR_FindRepeat(pcFindAll, true);
		}
	}

	if (pcFindAll != NULL)
	{
		delete[] pcFindAll;
		pcFindAll = NULL;
	}

	RR_Output("RepeatFile.txt");
	RR_SaveData("RR_Data.txt");
ã€€ã€€RR_Exit();
	return 0;
}
Output
1.6 RR_SaveData
bool RR_SaveData(const char *DataFilePath = "RR_Data.txt");
RoutineRequired HeaderRR_Output<LJDupRemover.h>Return Value
Return true if init succeed. Otherwise return false.

Parameters
DataFilePath : output Duplicate removal data file;
Example
int _tmain(int argc, _TCHAR* argv[])
{
	if (!RR_Init("RR_Data.txt","Data"))
	{
		printf("%s\r\n", RR_GetLastErrMsg());
		printf("å»é‡ç»„ä»¶åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·é€€å‡ºå¹¶æ£€æŸ¥ï¼è¯¥è”ç³»www.nlpir.org/æˆ–è€…æ–°æµªå¾®åš@ICTCLASå¼ åå¹³åšå£«ï¼\n");
		return-1;
	}

	vector<string> fileDir;
	string path = "./test/";
	string sContent = "";
	if(!gfn_bScanFiles(path.c_str(),fileDir))
	{
		printf("è·å–æ–‡ä»¶å¤¹ä¸­æ–‡ä»¶å¤±è´¥......\n");
		system("pause");
		return -1;
	}
	string sFilename;
	char *pcFindAll = new char[65565];
	for (int i = 0; i < fileDir.size();i++)
	{
		gfn_bReadFile((path + fileDir.at(i)).c_str(), sContent);
		sFilename = fileDir.at(i).c_str();
		sContent += "\r\n";
		if (RR_FileProcess(sContent.c_str(), sFilename.c_str()) == 1)
		{
			memset(pcFindAll, 0, 65565);
			RR_FindRepeat(pcFindAll, true);
		}
	}

	if (pcFindAll != NULL)
	{
		delete[] pcFindAll;
		pcFindAll = NULL;
	}

	RR_Output("RepeatFile.txt");
	RR_SaveData("RR_Data.txt");
ã€€ã€€RR_Exit();
	return 0;
}
Output
1.7 RR_GetLastErrMsg
const char* RR_GetLastErrMsg();
RoutineRequired HeaderRR_GetLastErrMsg<LJDupRemover.h>Return Value
Return err message if succeed. Otherwise return NULL.

Parameters
NULL
Example
int _tmain(int argc, _TCHAR* argv[])
{
	if (!RR_Init("RR_Data.txt","Data"))
	{
		printf("%s\r\n", RR_GetLastErrMsg());
		printf("å»é‡ç»„ä»¶åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·é€€å‡ºå¹¶æ£€æŸ¥ï¼è¯¥è”ç³»www.nlpir.org/æˆ–è€…æ–°æµªå¾®åš@ICTCLASå¼ åå¹³åšå£«ï¼\n");
		return-1;
	}

	vector<string> fileDir;
	string path = "./test/";
	string sContent = "";
	if(!gfn_bScanFiles(path.c_str(),fileDir))
	{
		printf("è·å–æ–‡ä»¶å¤¹ä¸­æ–‡ä»¶å¤±è´¥......\n");
		system("pause");
		return -1;
	}
	string sFilename;
	char *pcFindAll = new char[65565];
	for (int i = 0; i < fileDir.size();i++)
	{
		gfn_bReadFile((path + fileDir.at(i)).c_str(), sContent);
		sFilename = fileDir.at(i).c_str();
		sContent += "\r\n";
		if (RR_FileProcess(sContent.c_str(), sFilename.c_str()) == 1)
		{
			memset(pcFindAll, 0, 65565);
			RR_FindRepeat(pcFindAll, true);
		}
	}

	if (pcFindAll != NULL)
	{
		delete[] pcFindAll;
		pcFindAll = NULL;
	}

	RR_Output("RepeatFile.txt");
	RR_SaveData("RR_Data.txt");
ã€€ã€€RR_Exit();
	return 0;
}
Output

2  LJDupRemoverè¿è¡Œç¯å¢ƒ
   1. å¯ä»¥æ”¯æŒWindowsã€Linuxã€FreeBSDç­‰å¤šç§ç¯å¢ƒï¼Œæ”¯æŒæ™®é€šPCæœºå™¨å³å¯è¿è¡Œã€‚
   2. æ”¯æŒGBK/UTF-8/BIG5

3 å¸¸è§é—®é¢˜ï¼ˆFAQï¼‰
Q: LJDupRemoverç³»ç»Ÿåˆå§‹åŒ–è€æ˜¯å¤±è´¥
Answer: 
è¯·æ‚¨ä¿è¯LJDupRemover.useræ–‡ä»¶æœªè¿‡æœŸï¼Œå¦å¤–å¯å‚è€ƒ"20***.err"æ–‡ä»¶æŸ¥çœ‹é”™è¯¯ä¿¡æ¯














4 ä½œè€…ç®€ä»‹






å¼ åå¹³ åšå£« å‰¯æ•™æˆ ç¡•å¯¼
åŒ—äº¬ç†å·¥å¤§å­¦è®¡ç®—æœºå­¦é™¢ é™¢é•¿åŠ©ç†
åŒ—äº¬ç†å·¥å¤§å­¦ç½‘ç»œæœç´¢æŒ–æ˜ä¸å®‰å…¨å®éªŒå®¤ ä¸»ä»»
åœ°å€ï¼šåŒ—äº¬æµ·æ·€åŒºä¸­å…³æ‘å—å¤§è¡—5å· 100081
ç”µè¯ï¼š+86-10-68918642
Email:kevinzhang@bit.edu.cn
MSN:  pipy_zhang@msn.com;
ç½‘ç«™: http://ictclas.nlpir.org (è‡ªç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°)
åšå®¢:http://hi.baidu.com/drkevinzhang/
å¾®åš: @ICTCLASå¼ åå¹³åšå£«


Dr. Kevin Zhang  (å¼ åå¹³ï¼ŒZhang Hua-Ping)
Associate Professor, Graduate Supervisor
Dean Assistant, School of Computer
Director, Web Search,Mining and Security Lab.
Beijing Institute of Technology 
Add: No.5, South St.,Zhongguancun,Haidian District,Beijing,P.R.C  PC:100081
Tel: +86-10-68918642
Email:kevinzhang@bit.edu.cn
MSN:  pipy_zhang@msn.com;
Website: http://ictclas.nlpir.org (Natural Language Processing and Information Retrieval Sharing Platform)
Blog:http://hi.baidu.com/drkevinzhang/
Twitter: @ICTCLASå¼ åå¹³åšå£«


å»é‡ç»„ä»¶(LJDupRemover) æ¥å£æ–‡æ¡£            http://ICTCLAS.nlpir.org

NLPIR Copyright (c) 2013 Kevin Zhang. All rights reserved.    	               3/14

