



æ–‡æœ¬èšç±»ç»„ä»¶(Cluster) æ¥å£æ–‡æ¡£  
























http://ICTCLAS.nlpir.org/
@ICTCLASå¼ åå¹³åšå£«
2012-12
For the latest information about NLPIR, please visit Http://ICTCLAS.nlpir.org/
Document Information


ç›®å½•
æ–‡æœ¬èšç±»ç»„ä»¶(Cluster) æ¥å£æ–‡æ¡£	1
ç›®å½•	3
0. æ–‡æœ¬èšç±»ç»„ä»¶(åˆåClusterï¼‰ç®€ä»‹	4
1ï¼Cï¼‹ï¼‹æ¥å£	5
1.1 CLUS_Init	5
1.2 CLUS_Exit()	6
1.3 CLUS_SetParameter	7
1.4 CLUS_AddContent	8
1.5 CLUS_AddFile	10
1.6 CLUS_GetLatestResult	11
1.7 CLUS_CleanData	12
1.8 CLUS_GetLastErrMsg	13
2  Clusterè¿è¡Œç¯å¢ƒ	14
3 å¸¸è§é—®é¢˜ï¼ˆFAQï¼‰	15
Q1: Linuxè°ƒç”¨libLJCluster.soçš„æ—¶å€™ï¼Œé“¾æ¥ä¸ä¸Šåº“	15
Q2: LJClusterç³»ç»Ÿåˆå§‹åŒ–è€æ˜¯å¤±è´¥	15
4 ä½œè€…ç®€ä»‹	16


0. æ–‡æœ¬èšç±»ç»„ä»¶(åˆåClusterï¼‰ç®€ä»‹
ã€€ã€€æ–‡æœ¬èšç±»ï¼ˆText clusteringï¼‰æ–‡æ¡£èšç±»ä¸»è¦æ˜¯ä¾æ®è‘—åçš„èšç±»å‡è®¾ï¼šåŒç±»çš„æ–‡æ¡£ç›¸ä¼¼åº¦è¾ƒå¤§ï¼Œè€Œä¸åŒç±»çš„æ–‡æ¡£ç›¸ä¼¼åº¦è¾ƒå°ã€‚ä½œä¸ºä¸€ç§æ— ç›‘ç£çš„æœºå™¨å­¦ä¹ æ–¹æ³•ï¼Œèšç±»ç”±äºä¸ éœ€è¦è®­ç»ƒè¿‡ç¨‹ï¼Œä»¥åŠä¸éœ€è¦é¢„å…ˆå¯¹æ–‡æ¡£æ‰‹å·¥æ ‡æ³¨ç±»åˆ«ï¼Œå› æ­¤å…·æœ‰ä¸€å®šçš„çµæ´»æ€§å’Œè¾ƒé«˜çš„è‡ªåŠ¨åŒ–å¤„ç†èƒ½åŠ›ï¼Œå·²ç»æˆä¸ºå¯¹æ–‡æœ¬ä¿¡æ¯è¿›è¡Œæœ‰æ•ˆåœ°ç»„ç»‡ã€æ‘˜è¦å’Œå¯¼èˆªçš„é‡è¦æ‰‹ æ®µï¼Œä¸ºè¶Šæ¥è¶Šå¤šçš„ç ”ç©¶äººå‘˜æ‰€å…³æ³¨ã€‚
ã€€ã€€è‡ªç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°/J nHB-O(b1[
ã€€ã€€Y
ã€€ã€€X
ã€€ã€€
ã€€ã€€
ã€€ã€€   è®¿é—®http://ictclas.nlpir.org/(è‡ªç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°)ï¼Œæ‚¨å¯ä»¥è·å–Clusterç»„ä»¶çš„æœ€æ–°ç‰ˆæœ¬ï¼Œå¹¶æ¬¢è¿æ‚¨å…³æ³¨å¼ åå¹³åšå£«çš„æ–°æµªå¾®åš @ICTCLASå¼ åå¹³åšå£« äº¤æµã€‚1P_bR$vk0 è‡ªç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°1H9^+}NE*W;^
è‡ªç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°5H8]U ]4`s"Q^


6b;t.P s@)\J0ç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°-l3?3v"Z#X|{t#A!d Z å›¾1ï¼šæ–‡æœ¬èšç±»åŠŸèƒ½å±•ç¤º
è‡ªç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°-r
UM"c3u ]
1ï¼Cï¼‹ï¼‹æ¥å£
1.1 CLUS_Init
Init the analyzer and prepare necessary data for Cluster according the configure file.
bool CLUS_Init(const char *sDefaultPath,const char *sLicenseCode=0);
RoutineRequired HeaderCLUS_Init<LJCluster.h>Return Value
Return true if init succeed. Otherwise return false.
Parameters
sDefaultPath: Initial Directory Path, where file userfilterword.txt and Data directory stored.  the default value is 0, it indicates the initial directory is current working directory path
const char* sLicenceCode: licence coding of input string, 
Remarks
The CLUS_Init function must be invoked before any operation with Cluster. The whole system need call the function only once before starting Cluster. When stopping the system and make no more operation, Cluster_Exit should be invoked to destroy all working buffer. Any operation will fail if init do not succeed.
CLUS_Init fails mainly because of two reasons: 1) Required data is incompatible or missing 2) userfilterword.txt file missing or invalid parameters. Moreover, you could learn more from the log file 2014****.log in the current directory. 
Example
int main()
{
	if(!CLUS_Init("./Data/Cluster"))
	{
		printf("åˆ†ç±»æ¨¡å—åˆå§‹åŒ–å¤±è´¥\n");
		return -1;
	}
	
	CLUS_CleanData();
	CLUS_SetParameter(3, 2);
	char  sText[100] = "ä¸­åäººæ°‘å…±å’Œå›½æ­£å¼æˆç«‹çš„æ—¶é—´æ˜¯1949.10.1ï¼Œä»£è¡¨äººåæ­£å¼å½“å®¶ä½œä¸»çš„æ—¥å­åˆ°äº†";
	CLUS_AddContent(sText, sText);
	
	string sResult;
	CLUS_GetLatestResult("Result.xml");

	gfn_bReadFile("Result.xml", sResult);
	gfn_vReplaceSubstr(sResult, "\n", "\r\n");


	printf("sResult : %s \n",sResult.c_str());
	CLUS_Exit();
	return 0;
}
Output
1.2 CLUS_Exit()
Exit the program and free all resources and destroy all working buffer used in Cluster.
void CLUS_Exit();
RoutineRequired HeaderCLUS_Exit<LJCluster.h>Return Value
none.
Parameters
none
Remarks
The CLUS_Exit function must be invoked while stopping the system and make no more operation. And call CLUS_Exit() function to restart Cluster. 
Example
int main()
{
	if(!CLUS_Init("./Data/Cluster"))
	{
		printf("åˆ†ç±»æ¨¡å—åˆå§‹åŒ–å¤±è´¥\n");
		return -1;
	}
	
	CLUS_CleanData();
	CLUS_SetParameter(3, 2);
	char  sText[100] = "ä¸­åäººæ°‘å…±å’Œå›½æ­£å¼æˆç«‹çš„æ—¶é—´æ˜¯1949.10.1ï¼Œä»£è¡¨äººåæ­£å¼å½“å®¶ä½œä¸»çš„æ—¥å­åˆ°äº†";
	CLUS_AddContent(sText, sText);
	
	string sResult;
	CLUS_GetLatestResult("Result.xml");

	gfn_bReadFile("Result.xml", sResult);
	gfn_vReplaceSubstr(sResult, "\n", "\r\n");


	printf("sResult : %s \n",sResult.c_str());
	CLUS_Exit();
	return 0;
}
Output
1.3 CLUS_SetParameter
Set the parameter.
bool CLUS_SetParameter(int nMaxClus, int nMaxDoc);
RoutineRequired HeaderCLUS_SetParameter<LJCluster.h>Return Value
Return true if init succeed. Otherwise return false.
Parameters
Int nMaxClus:  Maximum  number of classes which output 
Int nMaxDoc:   Maximum  number of document which output inner each class
Remarks
This function must be invoked before other functions int the process,or
the default parameters were 2000;parameter is greater,more system memory,processing speed is slower, class and documents in the class  have been sorted according to the importance and timeliness.
Example
int main()
{
	if(!CLUS_Init("./Data/Cluster"))
	{
		printf("åˆ†ç±»æ¨¡å—åˆå§‹åŒ–å¤±è´¥\n");
		return -1;
	}
	
	CLUS_CleanData();
	CLUS_SetParameter(3, 2);
	char  sText[100] = "ä¸­åäººæ°‘å…±å’Œå›½æ­£å¼æˆç«‹çš„æ—¶é—´æ˜¯1949.10.1ï¼Œä»£è¡¨äººåæ­£å¼å½“å®¶ä½œä¸»çš„æ—¥å­åˆ°äº†";
	CLUS_AddContent(sText, sText);
	
	string sResult;
	CLUS_GetLatestResult("Result.xml");

	gfn_bReadFile("Result.xml", sResult);
	gfn_vReplaceSubstr(sResult, "\n", "\r\n");


	printf("sResult : %s \n",sResult.c_str());
	CLUS_Exit();
	return 0;
}
Output


1.4 CLUS_AddContent

Additional content.

bool CLUS_AddContent(const char *sText, const char* sSignature);
RoutineRequired HeaderCLUS_AddContent<LJCluster.h>Return Value
Return true if init succeed. Otherwise return false.
Parameters
sText: [IN] The Text content[The string which the last character is \0]
sSignature: [IN] The unique identifier [The string which the last character is \0]

Remarks
This function can be performed repeatedly before the result is printed
in the process
Example
int main()
{
	if(!CLUS_Init("./Data/Cluster"))
	{
		printf("åˆ†ç±»æ¨¡å—åˆå§‹åŒ–å¤±è´¥\n");
		return -1;
	}
	
	CLUS_CleanData();
	CLUS_SetParameter(3, 2);
	char  sText[100] = "ä¸­åäººæ°‘å…±å’Œå›½æ­£å¼æˆç«‹çš„æ—¶é—´æ˜¯1949.10.1ï¼Œä»£è¡¨äººåæ­£å¼å½“å®¶ä½œä¸»çš„æ—¥å­åˆ°äº†";
	CLUS_AddContent(sText, sText);
	
	string sResult;
	CLUS_GetLatestResult("Result.xml");

	gfn_bReadFile("Result.xml", sResult);
	gfn_vReplaceSubstr(sResult, "\n", "\r\n");


	printf("sResult : %s \n",sResult.c_str());
	CLUS_Exit();
	return 0;
}
Output
1.5 CLUS_AddFile
bool CLUS_AddFile(const char *sFileName, const char* sSignature); 
RoutineRequired HeaderCLUS_AddFile<LJCluster.h>Return Value
Return true if init succeed. Otherwise return false.

Parameters
sFileName: [IN] a full path of the file
sSignature: [IN] The unique identifier [The string which the last character is \0]
Remarks
This function can be performed repeatedly before the result is printed
in the process
Example
int main()
{
	if(!CLUS_Init("./Data/Cluster"))
	{
		const char* sMsg = CLUS_GetLastErrMsg();
		printf("åˆ†ç±»æ¨¡å—åˆå§‹åŒ–å¤±è´¥: %s\n",sMsg);
		return -1;
	}
	
	CLUS_CleanData();
	CLUS_SetParameter(3, 2);
	char  sText[100] = "ä¸­åäººæ°‘å…±å’Œå›½æ­£å¼æˆç«‹çš„æ—¶é—´æ˜¯1949.10.1ï¼Œä»£è¡¨äººåæ­£å¼å½“å®¶ä½œä¸»çš„æ—¥å­åˆ°äº†";
	CLUS_AddFile("æ—…æ¸¸ä¸šå·²æˆä¸ºè¥¿éƒ¨åœ°åŒºçš„é‡è¦äº§ä¸š.txt", "æ—…æ¸¸ä¸š");

	string sResult;
	CLUS_GetLatestResult("Result.xml");
	gfn_bReadFile("Result.xml", sResult);
	gfn_vReplaceSubstr(sResult, "\n", "\r\n");
	printf("sResult : %s \n",sResult.c_str());
	CLUS_Exit();
	return 0;
}
Output
1.6 CLUS_GetLatestResult
Print the result.
bool CLUS_GetLatestResult(const char* sXmlFileName);

RoutineRequired HeaderCLUS_GetLatestResult<LJCluster.h>Return Value
Return true if init succeed. Otherwise return false.
Parameters
sXmlFileName: [OUT]  XML file name; 
Remarks
Output clustering content to XML file;
Example
ã€€ã€€int main()
ã€€ã€€{
ã€€ã€€	if(!CLUS_Init("./Data/Cluster"))
ã€€ã€€	{
ã€€ã€€		printf("åˆ†ç±»æ¨¡å—åˆå§‹åŒ–å¤±è´¥\n");
ã€€ã€€		return -1;
ã€€ã€€	}
ã€€ã€€	
ã€€ã€€	CLUS_CleanData();
ã€€ã€€	CLUS_SetParameter(3, 2);
ã€€ã€€	char  sText[100] = "ä¸­åäººæ°‘å…±å’Œå›½æ­£å¼æˆç«‹çš„æ—¶é—´æ˜¯1949.10.1ï¼Œä»£è¡¨äººåæ­£å¼å½“å®¶ä½œä¸»çš„æ—¥å­åˆ°äº†";
ã€€ã€€	CLUS_AddContent(sText, sText);
ã€€ã€€	
ã€€ã€€	string sResult;
ã€€ã€€	CLUS_GetLatestResult("Result.xml");
ã€€ã€€	gfn_bReadFile("Result.xml", sResult);
ã€€ã€€	gfn_vReplaceSubstr(sResult, "\n", "\r\n");
ã€€ã€€	printf("sResult : %s \n",sResult.c_str());
ã€€ã€€	CLUS_Exit();
ã€€ã€€	return 0;
ã€€ã€€}
Output
1.7 CLUS_CleanData
Clean history data .
void CLUS_CleanData();

RoutineRequired HeaderCLUS_CleanData<LJCluster.h>Return Value
NULL.
Parameters
NULL
Remarks
Clean all history data
Example
ã€€ã€€int main()
ã€€ã€€{
ã€€ã€€	if(!CLUS_Init("./Data/Cluster"))
ã€€ã€€	{
ã€€ã€€		printf("åˆ†ç±»æ¨¡å—åˆå§‹åŒ–å¤±è´¥\n");
ã€€ã€€		return -1;
ã€€ã€€	}
ã€€ã€€	
ã€€ã€€	CLUS_CleanData();
ã€€ã€€	CLUS_SetParameter(3, 2);
ã€€ã€€	char  sText[100] = "ä¸­åäººæ°‘å…±å’Œå›½æ­£å¼æˆç«‹çš„æ—¶é—´æ˜¯1949.10.1ï¼Œä»£è¡¨äººåæ­£å¼å½“å®¶ä½œä¸»çš„æ—¥å­åˆ°äº†";
ã€€ã€€	CLUS_AddContent(sText, sText);
ã€€ã€€	
ã€€ã€€	string sResult;
ã€€ã€€	CLUS_GetLatestResult("Result.xml");
ã€€ã€€	gfn_bReadFile("Result.xml", sResult);
ã€€ã€€	gfn_vReplaceSubstr(sResult, "\n", "\r\n");
ã€€ã€€	printf("sResult : %s \n",sResult.c_str());
ã€€ã€€	CLUS_Exit();
ã€€ã€€	return 0;
ã€€ã€€}
Output
1.8 CLUS_GetLastErrMsg

const char* CLUS_GetLastErrMsg();

RoutineRequired HeaderCLUS_GetLastErrMsg<LJCluster.h>Return Value
The lastest error information.
Parameters
NULL
Remarks
Get the latest error information.
Example
int main()
{
	if(!CLUS_Init("./Data/Cluster"))
	{
		const char* sMsg = CLUS_GetLastErrMsg();
		printf("åˆ†ç±»æ¨¡å—åˆå§‹åŒ–å¤±è´¥: %s\n",sMsg);
		return -1;
	}
	CLUS_Exit();
	return 0;
}
Output


2  Clusterè¿è¡Œç¯å¢ƒ
   1. å¯ä»¥æ”¯æŒWindowsã€Linuxã€FreeBSDç­‰å¤šç§ç¯å¢ƒï¼Œæ”¯æŒæ™®é€šPCæœºå™¨å³å¯è¿è¡Œã€‚
   2. æ”¯æŒGBK/UTF-8/BIG5

3 å¸¸è§é—®é¢˜ï¼ˆFAQï¼‰
Q1: Linuxè°ƒç”¨libLJCluster.soçš„æ—¶å€™ï¼Œé“¾æ¥ä¸ä¸Šåº“
ä¾‹å¦‚æ‰§è¡Œç¤ºä¾‹ç¨‹åºç»“æœå¦‚ä¸‹ï¼š
[root@localhost linux_c_sample]# ./test 
./test: error while loading shared libraries: libLJCluster.so: cannot open shared object file: No such file or directory
Answer: 
åº”å½“è®¾ç½®ç³»ç»Ÿçš„LD_LIBRARY_PATHï¼Œå³ï¼šexport LD_LIBRARY_PATH=./
å¹¶ä¸”è¯·ä¿è¯åœ¨æœ¬ç›®å½•ä¹Ÿæœ‰libNLPIR.so
Q2: LJClusterç³»ç»Ÿåˆå§‹åŒ–è€æ˜¯å¤±è´¥
Answer: 
è¯·æ‚¨ä¿è¯åœ¨æ‚¨çš„Dataç›®å½•ä¸­åŒ…å«æœ‰userfilterword.txtï¼Œå¹¶ä¸”cluster.useræ–‡ä»¶æœªè¿‡æœŸï¼Œå¦å¤–å¯å‚è€ƒ"20***.err"æ–‡ä»¶æŸ¥çœ‹é”™è¯¯ä¿¡æ¯













4 ä½œè€…ç®€ä»‹






å¼ åå¹³ åšå£« å‰¯æ•™æˆ ç¡•å¯¼
åŒ—äº¬ç†å·¥å¤§å­¦è®¡ç®—æœºå­¦é™¢ é™¢é•¿åŠ©ç†
åŒ—äº¬ç†å·¥å¤§å­¦ç½‘ç»œæœç´¢æŒ–æ˜ä¸å®‰å…¨å®éªŒå®¤ ä¸»ä»»
åœ°å€ï¼šåŒ—äº¬æµ·æ·€åŒºä¸­å…³æ‘å—å¤§è¡—5å· 100081
ç”µè¯ï¼š+86-10-68918642
Email:kevinzhang@bit.edu.cn
MSN:  pipy_zhang@msn.com;
ç½‘ç«™: http://ictclas.nlpir.org (è‡ªç„¶è¯­è¨€å¤„ç†ä¸ä¿¡æ¯æ£€ç´¢å…±äº«å¹³å°)
åšå®¢:http://hi.baidu.com/drkevinzhang/
å¾®åš: @ICTCLASå¼ åå¹³åšå£«


Dr. Kevin Zhang  (å¼ åå¹³ï¼ŒZhang Hua-Ping)
Associate Professor, Graduate Supervisor
Dean Assistant, School of Computer
Director, Web Search,Mining and Security Lab.
Beijing Institute of Technology 
Add: No.5, South St.,Zhongguancun,Haidian District,Beijing,P.R.C  PC:100081
Tel: +86-10-68918642
Email:kevinzhang@bit.edu.cn
MSN:  pipy_zhang@msn.com;
Website: http://ictclas.nlpir.org (Natural Language Processing and Information Retrieval Sharing Platform)
Blog:http://hi.baidu.com/drkevinzhang/
Twitter: @ICTCLASå¼ åå¹³åšå£«


æ–‡æœ¬èšç±»ç»„ä»¶(Cluster) æ¥å£æ–‡æ¡£            http://ICTCLAS.nlpir.org

NLPIR Copyright (c) 2013 Kevin Zhang. All rights reserved.    	               2/15

